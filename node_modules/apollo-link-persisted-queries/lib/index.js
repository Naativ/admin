import { ApolloLink, Observable } from 'apollo-link';
var sha256 = require('hash.js/lib/hash/sha/256');
import { print } from 'graphql/language/printer';
export var VERSION = 1;
export var defaultGenerateHash = function (query) {
    return sha256()
        .update(print(query))
        .digest('hex');
};
export var defaultOptions = {
    generateHash: defaultGenerateHash,
    disable: function (_a) {
        var graphQLErrors = _a.graphQLErrors, operation = _a.operation;
        if (graphQLErrors &&
            graphQLErrors.some(function (_a) {
                var message = _a.message;
                return message === 'PersistedQueryNotSupported';
            })) {
            return true;
        }
        var response = operation.getContext().response;
        if (response &&
            response.status &&
            (response.status === 400 || response.status === 500)) {
            return true;
        }
        return false;
    },
};
export var createPersistedQueryLink = function (_a) {
    var _b = _a === void 0 ? defaultOptions : _a, generateHash = _b.generateHash, disable = _b.disable;
    var supportsPersistedQueries = true;
    var calculated = new Map();
    return new ApolloLink(function (operation, forward) {
        var query = operation.query;
        var hashError;
        if (supportsPersistedQueries) {
            var hash = calculated.get(query);
            if (!hash) {
                try {
                    hash = generateHash(query);
                    calculated.set(query, hash);
                }
                catch (e) {
                    hashError = e;
                }
            }
            operation.extensions.persistedQuery = {
                version: VERSION,
                sha256Hash: hash,
            };
        }
        return new Observable(function (observer) {
            if (hashError) {
                observer.error(hashError);
                return;
            }
            var subscription;
            var retried = false;
            var retry = function (_a, cb) {
                var response = _a.response, networkError = _a.networkError;
                if ((!retried && (response && response.errors)) || networkError) {
                    retried = true;
                    var disablePayload = {
                        response: response,
                        networkError: networkError,
                        operation: operation,
                        graphQLErrors: response ? response.errors : null,
                    };
                    supportsPersistedQueries = !disable(disablePayload);
                    if ((response &&
                        response.errors.some(function (_a) {
                            var message = _a.message;
                            return message === 'PersistedQueryNotFound';
                        })) ||
                        !supportsPersistedQueries) {
                        if (subscription)
                            subscription.unsubscribe();
                        operation.setContext({
                            http: {
                                includeQuery: true,
                                includeExtensions: supportsPersistedQueries,
                            },
                        });
                        subscription = forward(operation).subscribe(handler);
                        return;
                    }
                }
                cb();
            };
            var handler = {
                next: function (response) {
                    retry({ response: response }, function () { return observer.next(response); });
                },
                error: function (networkError) {
                    retry({ networkError: networkError }, function () { return observer.error(networkError); });
                },
                complete: observer.complete.bind(observer),
            };
            operation.setContext({
                http: {
                    includeQuery: !supportsPersistedQueries,
                    includeExtensions: supportsPersistedQueries,
                },
            });
            subscription = forward(operation).subscribe(handler);
            return function () {
                if (subscription)
                    subscription.unsubscribe();
            };
        });
    });
};
//# sourceMappingURL=index.js.map