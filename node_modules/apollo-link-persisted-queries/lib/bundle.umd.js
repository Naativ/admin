(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('apollo-link'), require('graphql/language/printer')) :
	typeof define === 'function' && define.amd ? define(['exports', 'apollo-link', 'graphql/language/printer'], factory) :
	(factory((global.persistedQueryLink = {}),global.apolloLink,global.graphql_language_printer));
}(this, (function (exports,apolloLink,graphql_language_printer) { 'use strict';

var sha256 = require('hash.js/lib/hash/sha/256');
var VERSION = 1;
var defaultGenerateHash = function (query) {
    return sha256()
        .update(graphql_language_printer.print(query))
        .digest('hex');
};
var defaultOptions = {
    generateHash: defaultGenerateHash,
    disable: function (_a) {
        var graphQLErrors = _a.graphQLErrors, operation = _a.operation;
        if (graphQLErrors &&
            graphQLErrors.some(function (_a) {
                var message = _a.message;
                return message === 'PersistedQueryNotSupported';
            })) {
            return true;
        }
        var response = operation.getContext().response;
        if (response &&
            response.status &&
            (response.status === 400 || response.status === 500)) {
            return true;
        }
        return false;
    },
};
var createPersistedQueryLink = function (_a) {
    var _b = _a === void 0 ? defaultOptions : _a, generateHash = _b.generateHash, disable = _b.disable;
    var supportsPersistedQueries = true;
    var calculated = new Map();
    return new apolloLink.ApolloLink(function (operation, forward) {
        var query = operation.query;
        var hashError;
        if (supportsPersistedQueries) {
            var hash = calculated.get(query);
            if (!hash) {
                try {
                    hash = generateHash(query);
                    calculated.set(query, hash);
                }
                catch (e) {
                    hashError = e;
                }
            }
            operation.extensions.persistedQuery = {
                version: VERSION,
                sha256Hash: hash,
            };
        }
        return new apolloLink.Observable(function (observer) {
            if (hashError) {
                observer.error(hashError);
                return;
            }
            var subscription;
            var retried = false;
            var retry = function (_a, cb) {
                var response = _a.response, networkError = _a.networkError;
                if ((!retried && (response && response.errors)) || networkError) {
                    retried = true;
                    var disablePayload = {
                        response: response,
                        networkError: networkError,
                        operation: operation,
                        graphQLErrors: response ? response.errors : null,
                    };
                    supportsPersistedQueries = !disable(disablePayload);
                    if ((response &&
                        response.errors.some(function (_a) {
                            var message = _a.message;
                            return message === 'PersistedQueryNotFound';
                        })) ||
                        !supportsPersistedQueries) {
                        if (subscription)
                            subscription.unsubscribe();
                        operation.setContext({
                            http: {
                                includeQuery: true,
                                includeExtensions: supportsPersistedQueries,
                            },
                        });
                        subscription = forward(operation).subscribe(handler);
                        return;
                    }
                }
                cb();
            };
            var handler = {
                next: function (response) {
                    retry({ response: response }, function () { return observer.next(response); });
                },
                error: function (networkError) {
                    retry({ networkError: networkError }, function () { return observer.error(networkError); });
                },
                complete: observer.complete.bind(observer),
            };
            operation.setContext({
                http: {
                    includeQuery: !supportsPersistedQueries,
                    includeExtensions: supportsPersistedQueries,
                },
            });
            subscription = forward(operation).subscribe(handler);
            return function () {
                if (subscription)
                    subscription.unsubscribe();
            };
        });
    });
};

exports.VERSION = VERSION;
exports.defaultGenerateHash = defaultGenerateHash;
exports.defaultOptions = defaultOptions;
exports.createPersistedQueryLink = createPersistedQueryLink;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=bundle.umd.js.map
