{"remainingRequest":"/Users/narfdre/Code/hexly/admin/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/narfdre/Code/hexly/admin/src/views/assets/UploadDialog.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/narfdre/Code/hexly/admin/src/views/assets/UploadDialog.vue","mtime":1574205365000},{"path":"/Users/narfdre/Code/hexly/admin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/narfdre/Code/hexly/admin/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/narfdre/Code/hexly/admin/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/narfdre/Code/hexly/admin/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\n\nimport path from 'ramda/src/path'\n// import TermsAndConditions from '@/components/TermsAndConditions.vue'\n\nimport vueFilePond from 'vue-filepond'\n\nimport FilePondPluginImageExifOrientation from 'filepond-plugin-image-exif-orientation'\nimport FilePondPluginImageResize from 'filepond-plugin-image-resize'\nimport FilePondPluginImageTransform from 'filepond-plugin-image-transform'\nimport FilePondPluginFilePoster from 'filepond-plugin-file-poster'\nimport FilePondPluginImagePreview from 'filepond-plugin-image-preview/dist/filepond-plugin-image-preview.esm.js'\nimport FilePondPluginFileValidateType from 'filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js'\n\n// Import styles\nimport 'filepond/dist/filepond.min.css'\nimport 'filepond-plugin-file-poster/dist/filepond-plugin-file-poster.css'\nimport 'filepond-plugin-image-preview/dist/filepond-plugin-image-preview.min.css'\nimport { Promise } from 'bluebird'\n\nimport { mapActions, mapGetters } from 'vuex'\nimport { ContentActions, ContentGetters } from '@/content/ContentStore'\nimport { createAsset } from '@/content/ContentService'\n// import { rules } from '@/utils/Validation.js'\n\n// Create FilePond component\nconst FilePond = vueFilePond(FilePondPluginImageTransform, FilePondPluginFileValidateType, FilePondPluginImagePreview, FilePondPluginFilePoster, FilePondPluginImageResize, FilePondPluginImageExifOrientation)\n\nexport default {\n  name: 'UploadDialog',\n  components: {\n    FilePond\n    // TermsAndConditions\n  },\n  mounted() {\n    this.refreshMeta()\n  },\n  data() {\n    return {\n      error: null,\n      loading: false,\n      uploadDialog: false,\n      fileData: {},\n      files: [],\n      currentFile: null,\n      assetTypes: [],\n      assetTags: [],\n      thumbnail: null,\n      assetSearch: {\n        pageSize: 25,\n        page: 1\n      },\n      success: null,\n      assetId: null\n      // rules\n    }\n  },\n  computed: {\n    ...mapGetters({\n      assetMeta: ContentGetters.assetMeta\n    })\n  },\n  methods: {\n    ...mapActions({\n      refreshMeta: ContentActions.REFRESH_ASSET_META,\n      refreshLibrary: ContentActions.REFRESH_LIBRARY_ASSETS\n    }),\n    getTags() {\n\n    },\n    filtered(tags, filters) {\n      return tags.filter(tag => filters.indexOf(tag.id) > -1)\n    },\n    // fieldName is the name of the input field\n    // file is the actual file object to send\n    async process(fieldName, file, metadata, load, error, progress, abort) {\n      this.success = null\n      this.assetId = null\n      const { fileData, assetMeta } = this\n      if (!fileData.name || !fileData.desc || !fileData.tags) {\n        return error('Please fill out the whole form ')\n      }\n\n      let asset, tn\n      try {\n        const type = assetMeta.types.find(e => e.mimeType === file.type)\n        if (!type) {\n          console.warn('Unsupported type', { file, assetMeta })\n          return error('Could not determine a supported file type for ' + file.type)\n        }\n\n        const [provider] = assetMeta.providers\n        if (!provider) {\n          console.warn('No known upload provider', { file, assetMeta })\n          return error('Could not determine a supported upload destination. Please contact support')\n        }\n\n        // const profileAudience = assetMeta.audiences.find(_ => _.key === 'aud:profile')\n        const anyTags = fileData.tags.map((fdMap, i) => {\n          return fdMap.id\n        })\n\n        const payload = {\n          typeId: type.id,\n          tenantIntegrationId: provider.tenantIntegrationId,\n          slug: new Date().getTime().toString(),\n          name: fileData.name,\n          description: fileData.desc,\n          anyTags,\n          public: false,\n          ownerReadable: true\n        }\n\n        if (this.thumbnail && file.type.indexOf('video') === -1 && file.type.indexOf('pdf') === -1) {\n          payload.thumbnail = {\n            typeId: this.thumbnail.type.id,\n            tenantIntegrationId: provider.tenantIntegrationId,\n            slug: 'thumbnail_' + new Date().getTime().toString(),\n            name: 'thumbnail_' + fileData.name,\n            description: 'Thumbnail for ' + fileData.name,\n            public: true,\n            ownerReadable: false\n          }\n        }\n\n        const result = await createAsset(payload)\n        this.assetId = result.assetId\n        asset = path(['destination'], result)\n        tn = path(['thumbnail'], result)\n      } catch (e) {\n        console.warn('failed meta stuff', e)\n        return error('We were unable to associate your upload correctly. Please contact support')\n      }\n\n      // THIS IS WHERE WE WANT TO SEND THE REQUEST TO THE S3 SIGNED URL\n      if (tn && file.type.indexOf('video') === -1 && file.type.indexOf('pdf') === -1) {\n        try {\n          await this.sendSigned(this.thumbnail.file, tn)\n        } catch (err) {\n          console.warn('failed uploading thumbnail', err)\n        }\n      }\n      const request = await this.sendSigned(file, asset, progress)\n\n      // await this.$emit('uploaded', asset)\n      await this.refreshLibrary(this.assetSearch)\n      if (request.status >= 200 && request.status < 300) {\n        // the load method accepts either a string (id) or an object\n        load(request.responseText)\n        this.done()\n      } else {\n        // Can call the error method if something is wrong, should exit after\n        const err = new Error('Non 200 upload response returned')\n        err.request = request\n        error('Did not receive a valid upload response. Please contact support.')\n      }\n\n      // Should expose an abort method so the request can be cancelled\n      return {\n        abort: () => {\n          // This function is entered if the user has tapped the cancel button\n          request.abort()\n\n          // Let FilePond know the request has been cancelled\n          abort()\n          this.error = 'Upload aborted'\n        }\n      }\n    },\n    async beforeAddFile(file) {\n      const that = this\n      that.thumbnail = null\n      return new Promise((resolve, reject) => {\n        if (file.fileType.indexOf('video') > -1) {\n          const canvas = document.createElement('canvas')\n          const video = document.createElement('video')\n          video.type = file.type\n          video.src = URL.createObjectURL(file.file)\n          video.currentTime = 2\n          video.onloadeddata = () => {\n            const ratio = Math.min(500 / video.videoWidth, 500 / video.videoHeight)\n            canvas.height = video.videoHeight * ratio\n            canvas.width = video.videoWidth * ratio\n            canvas.getContext('2d').drawImage(video, 0, 0, video.videoWidth * ratio, video.videoHeight * ratio)\n            const thumbnail = canvas.toDataURL('image/png')\n            file.setMetadata('poster', thumbnail)\n            var blobBin = atob(thumbnail.split(',')[1])\n            var array = []\n            for (var i = 0; i < blobBin.length; i++) {\n              array.push(blobBin.charCodeAt(i))\n            }\n            that.thumbnail = {\n              type: that.assetMeta.types.find(e => e.mimeType === 'image/png'),\n              file: new Blob([new Uint8Array(array)], { type: 'image/png' })\n            }\n\n            resolve(true)\n          }\n        } else {\n          resolve(true)\n        }\n      })\n    },\n    async sendSigned(file, asset, progress) {\n      const { destination } = asset\n      const formData = new FormData()\n      Object.keys(destination.fields)\n        .map(f => {\n          formData.append(f, destination.fields[f])\n          return f + ' => ' + destination.fields[f]\n        })\n        .join('\\n')\n      formData.append('file', file, file.name)\n\n      const request = new XMLHttpRequest()\n      request.open('POST', destination.url)\n\n      // Should call the progress method to update the progress to 100% before calling load\n      // Setting computable to false switches the loading indicator to infinite mode\n      if (progress) {\n        request.upload.onprogress = (e) => {\n          progress(e.lengthComputable, e.loaded, e.total)\n        }\n      }\n\n      return new Promise((resolve) => {\n        // Should call the load method when done and pass the returned server file id\n        // this server file id is then used later on when reverting or restoring a file\n        // so your server knows which file to return without exposing that info to the client\n        request.onload = () => {\n          resolve(request)\n        }\n        request.send(formData)\n      })\n    },\n    async onaddfile(error, file) {\n      if (error) {\n        if (file && file.main && file.sub) {\n          this.error = `${file.main}: ${file.sub}`\n        } else {\n          this.error = error.body\n        }\n      }\n      if (this.currentFile || error) {\n        return false\n      }\n      this.currentFile = file\n      this.$set(this, 'fileData', {\n        name: file.filename,\n        desc: '',\n        tags: [],\n        type: null\n      })\n    },\n    onError(error, file) {\n      this.loading = false\n      if (error) {\n        if (file && file.main && file.sub) {\n          this.error = `${file.main}: ${file.sub}`\n        } else {\n          this.error = error.body\n        }\n      }\n    },\n    onremovefile(file) {\n      this.error = null\n      this.currentFile = null\n      this.fileData = null\n    },\n    async upload() {\n      this.loading = true\n      this.$refs.pond._pond.setOptions({\n        server: {\n          process: this.process\n        }\n      })\n      this.error = null\n      await this.$refs.pond.processFile()\n      this.loading = false\n    },\n    async done(reason) {\n      this.success = 'Uploaded Asset ' + this.assetId\n      setTimeout(this.clearSuccess, 5000)\n      this.error = null\n      this.currentFile = null\n      this.fileData = null\n      this.$refs.pond.removeFile()\n      this.thumbnail = null\n      // this.$emit('assetsUploaded')\n      await this.refreshLibrary(this.assetSearch)\n      this.uploadDialog = false\n    },\n    clearSuccess() {\n      this.success = null\n    }\n  }\n}\n",{"version":3,"sources":["UploadDialog.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgFA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"UploadDialog.vue","sourceRoot":"src/views/assets","sourcesContent":["<template>\n  <v-layout justify-space-around column align-center>\n    <v-card class=\"upload\" :fullscreen=\"$vuetify.breakpoint.xs\">\n      <v-card-title class=\"application-title; justify-center\">\n        <h3>Select a Video or Image to Upload</h3>\n      </v-card-title>\n      <v-divider></v-divider>\n      <v-card-text>\n        <v-alert v-if=\"error\" type=\"error\" :value=\"error\">{{error}}</v-alert>\n        <file-pond\n          name=\"libaryUpload\"\n          ref=\"pond\"\n          class-name=\"my-pond\"\n          label-idle=\"Drop file here or click to browse files\"\n          :allow-multiple=\"false\"\n          :instantUpload=\"false\"\n          :allow-revert=\"false\"\n          :imageTransformOutputQuality=\"95\"\n          :allowImageExifOrientation=\"true\"\n          accepted-file-types=\"image/jpeg, image/png, video/webm, video/mp4, video/mov, video/quicktime, application/pdf\"\n          :files=\"files\"\n          :beforeAddFile=\"beforeAddFile\"\n          @addfile=\"onaddfile\"\n          @removefile=\"onremovefile\"\n          @error=\"onError\"\n        />\n        <div v-if=\"currentFile && !loading\">\n          <v-subheader>Asset Title</v-subheader>\n          <v-text-field\n            solo\n            :label=\"`Name your ${currentFile.fileType.split('/')[0]}`\"\n            v-model=\"fileData.name\"\n            counter=\"100\"\n            maxLength=\"100\"\n          />\n          <br>\n          <v-textarea\n            solo\n            label=\"Please provide a short description\"\n            v-model=\"fileData.desc\"\n            counter=\"250\"\n            maxLength=\"250\"\n          ></v-textarea>\n          <v-combobox\n            solo\n            persistent-hint\n            label=\"Select relevant tags\"\n            v-model=\"fileData.tags\"\n            item-text=\"name\"\n            item-value=\"id\"\n            :items=\"assetMeta.allTags\"\n            chips\n            deletable-chips\n            multiple\n            :return-object=\"true\"\n          />\n          <v-card-actions class=\"justify-end\">\n            <v-btn :loading=\"loading\" color=\"primary\" @click=\"upload\">Upload</v-btn>\n          </v-card-actions>\n        </div>\n      </v-card-text>\n      <v-divider></v-divider>\n        <v-card-actions class=\"justify-center\">\n        <v-btn :disabled=\"loading\" color=\"primary\" flat @click=\"done\">Exit</v-btn>\n        </v-card-actions>\n        <div class=\"text-xs-center\">\n          <small>Exiting before Uploading will Cancel Action</small>\n        </div>\n    </v-card>\n    <v-alert\n      transition=\"slide-y-transition\"\n      type=\"success\"\n      :value=\"success\">\n        {{success}}\n      </v-alert>\n  </v-layout>\n</template>\n\n<script>\n\nimport path from 'ramda/src/path'\n// import TermsAndConditions from '@/components/TermsAndConditions.vue'\n\nimport vueFilePond from 'vue-filepond'\n\nimport FilePondPluginImageExifOrientation from 'filepond-plugin-image-exif-orientation'\nimport FilePondPluginImageResize from 'filepond-plugin-image-resize'\nimport FilePondPluginImageTransform from 'filepond-plugin-image-transform'\nimport FilePondPluginFilePoster from 'filepond-plugin-file-poster'\nimport FilePondPluginImagePreview from 'filepond-plugin-image-preview/dist/filepond-plugin-image-preview.esm.js'\nimport FilePondPluginFileValidateType from 'filepond-plugin-file-validate-type/dist/filepond-plugin-file-validate-type.esm.js'\n\n// Import styles\nimport 'filepond/dist/filepond.min.css'\nimport 'filepond-plugin-file-poster/dist/filepond-plugin-file-poster.css'\nimport 'filepond-plugin-image-preview/dist/filepond-plugin-image-preview.min.css'\nimport { Promise } from 'bluebird'\n\nimport { mapActions, mapGetters } from 'vuex'\nimport { ContentActions, ContentGetters } from '@/content/ContentStore'\nimport { createAsset } from '@/content/ContentService'\n// import { rules } from '@/utils/Validation.js'\n\n// Create FilePond component\nconst FilePond = vueFilePond(FilePondPluginImageTransform, FilePondPluginFileValidateType, FilePondPluginImagePreview, FilePondPluginFilePoster, FilePondPluginImageResize, FilePondPluginImageExifOrientation)\n\nexport default {\n  name: 'UploadDialog',\n  components: {\n    FilePond\n    // TermsAndConditions\n  },\n  mounted() {\n    this.refreshMeta()\n  },\n  data() {\n    return {\n      error: null,\n      loading: false,\n      uploadDialog: false,\n      fileData: {},\n      files: [],\n      currentFile: null,\n      assetTypes: [],\n      assetTags: [],\n      thumbnail: null,\n      assetSearch: {\n        pageSize: 25,\n        page: 1\n      },\n      success: null,\n      assetId: null\n      // rules\n    }\n  },\n  computed: {\n    ...mapGetters({\n      assetMeta: ContentGetters.assetMeta\n    })\n  },\n  methods: {\n    ...mapActions({\n      refreshMeta: ContentActions.REFRESH_ASSET_META,\n      refreshLibrary: ContentActions.REFRESH_LIBRARY_ASSETS\n    }),\n    getTags() {\n\n    },\n    filtered(tags, filters) {\n      return tags.filter(tag => filters.indexOf(tag.id) > -1)\n    },\n    // fieldName is the name of the input field\n    // file is the actual file object to send\n    async process(fieldName, file, metadata, load, error, progress, abort) {\n      this.success = null\n      this.assetId = null\n      const { fileData, assetMeta } = this\n      if (!fileData.name || !fileData.desc || !fileData.tags) {\n        return error('Please fill out the whole form ')\n      }\n\n      let asset, tn\n      try {\n        const type = assetMeta.types.find(e => e.mimeType === file.type)\n        if (!type) {\n          console.warn('Unsupported type', { file, assetMeta })\n          return error('Could not determine a supported file type for ' + file.type)\n        }\n\n        const [provider] = assetMeta.providers\n        if (!provider) {\n          console.warn('No known upload provider', { file, assetMeta })\n          return error('Could not determine a supported upload destination. Please contact support')\n        }\n\n        // const profileAudience = assetMeta.audiences.find(_ => _.key === 'aud:profile')\n        const anyTags = fileData.tags.map((fdMap, i) => {\n          return fdMap.id\n        })\n\n        const payload = {\n          typeId: type.id,\n          tenantIntegrationId: provider.tenantIntegrationId,\n          slug: new Date().getTime().toString(),\n          name: fileData.name,\n          description: fileData.desc,\n          anyTags,\n          public: false,\n          ownerReadable: true\n        }\n\n        if (this.thumbnail && file.type.indexOf('video') === -1 && file.type.indexOf('pdf') === -1) {\n          payload.thumbnail = {\n            typeId: this.thumbnail.type.id,\n            tenantIntegrationId: provider.tenantIntegrationId,\n            slug: 'thumbnail_' + new Date().getTime().toString(),\n            name: 'thumbnail_' + fileData.name,\n            description: 'Thumbnail for ' + fileData.name,\n            public: true,\n            ownerReadable: false\n          }\n        }\n\n        const result = await createAsset(payload)\n        this.assetId = result.assetId\n        asset = path(['destination'], result)\n        tn = path(['thumbnail'], result)\n      } catch (e) {\n        console.warn('failed meta stuff', e)\n        return error('We were unable to associate your upload correctly. Please contact support')\n      }\n\n      // THIS IS WHERE WE WANT TO SEND THE REQUEST TO THE S3 SIGNED URL\n      if (tn && file.type.indexOf('video') === -1 && file.type.indexOf('pdf') === -1) {\n        try {\n          await this.sendSigned(this.thumbnail.file, tn)\n        } catch (err) {\n          console.warn('failed uploading thumbnail', err)\n        }\n      }\n      const request = await this.sendSigned(file, asset, progress)\n\n      // await this.$emit('uploaded', asset)\n      await this.refreshLibrary(this.assetSearch)\n      if (request.status >= 200 && request.status < 300) {\n        // the load method accepts either a string (id) or an object\n        load(request.responseText)\n        this.done()\n      } else {\n        // Can call the error method if something is wrong, should exit after\n        const err = new Error('Non 200 upload response returned')\n        err.request = request\n        error('Did not receive a valid upload response. Please contact support.')\n      }\n\n      // Should expose an abort method so the request can be cancelled\n      return {\n        abort: () => {\n          // This function is entered if the user has tapped the cancel button\n          request.abort()\n\n          // Let FilePond know the request has been cancelled\n          abort()\n          this.error = 'Upload aborted'\n        }\n      }\n    },\n    async beforeAddFile(file) {\n      const that = this\n      that.thumbnail = null\n      return new Promise((resolve, reject) => {\n        if (file.fileType.indexOf('video') > -1) {\n          const canvas = document.createElement('canvas')\n          const video = document.createElement('video')\n          video.type = file.type\n          video.src = URL.createObjectURL(file.file)\n          video.currentTime = 2\n          video.onloadeddata = () => {\n            const ratio = Math.min(500 / video.videoWidth, 500 / video.videoHeight)\n            canvas.height = video.videoHeight * ratio\n            canvas.width = video.videoWidth * ratio\n            canvas.getContext('2d').drawImage(video, 0, 0, video.videoWidth * ratio, video.videoHeight * ratio)\n            const thumbnail = canvas.toDataURL('image/png')\n            file.setMetadata('poster', thumbnail)\n            var blobBin = atob(thumbnail.split(',')[1])\n            var array = []\n            for (var i = 0; i < blobBin.length; i++) {\n              array.push(blobBin.charCodeAt(i))\n            }\n            that.thumbnail = {\n              type: that.assetMeta.types.find(e => e.mimeType === 'image/png'),\n              file: new Blob([new Uint8Array(array)], { type: 'image/png' })\n            }\n\n            resolve(true)\n          }\n        } else {\n          resolve(true)\n        }\n      })\n    },\n    async sendSigned(file, asset, progress) {\n      const { destination } = asset\n      const formData = new FormData()\n      Object.keys(destination.fields)\n        .map(f => {\n          formData.append(f, destination.fields[f])\n          return f + ' => ' + destination.fields[f]\n        })\n        .join('\\n')\n      formData.append('file', file, file.name)\n\n      const request = new XMLHttpRequest()\n      request.open('POST', destination.url)\n\n      // Should call the progress method to update the progress to 100% before calling load\n      // Setting computable to false switches the loading indicator to infinite mode\n      if (progress) {\n        request.upload.onprogress = (e) => {\n          progress(e.lengthComputable, e.loaded, e.total)\n        }\n      }\n\n      return new Promise((resolve) => {\n        // Should call the load method when done and pass the returned server file id\n        // this server file id is then used later on when reverting or restoring a file\n        // so your server knows which file to return without exposing that info to the client\n        request.onload = () => {\n          resolve(request)\n        }\n        request.send(formData)\n      })\n    },\n    async onaddfile(error, file) {\n      if (error) {\n        if (file && file.main && file.sub) {\n          this.error = `${file.main}: ${file.sub}`\n        } else {\n          this.error = error.body\n        }\n      }\n      if (this.currentFile || error) {\n        return false\n      }\n      this.currentFile = file\n      this.$set(this, 'fileData', {\n        name: file.filename,\n        desc: '',\n        tags: [],\n        type: null\n      })\n    },\n    onError(error, file) {\n      this.loading = false\n      if (error) {\n        if (file && file.main && file.sub) {\n          this.error = `${file.main}: ${file.sub}`\n        } else {\n          this.error = error.body\n        }\n      }\n    },\n    onremovefile(file) {\n      this.error = null\n      this.currentFile = null\n      this.fileData = null\n    },\n    async upload() {\n      this.loading = true\n      this.$refs.pond._pond.setOptions({\n        server: {\n          process: this.process\n        }\n      })\n      this.error = null\n      await this.$refs.pond.processFile()\n      this.loading = false\n    },\n    async done(reason) {\n      this.success = 'Uploaded Asset ' + this.assetId\n      setTimeout(this.clearSuccess, 5000)\n      this.error = null\n      this.currentFile = null\n      this.fileData = null\n      this.$refs.pond.removeFile()\n      this.thumbnail = null\n      // this.$emit('assetsUploaded')\n      await this.refreshLibrary(this.assetSearch)\n      this.uploadDialog = false\n    },\n    clearSuccess() {\n      this.success = null\n    }\n  }\n}\n</script>\n<style scoped>\n.upload {\n  margin-top: 20px;\n  width: 60%;\n}\n</style>\n"]}]}